#!/bin/bash 
# Helps updating PKGBUILDs against different Arch Linux projects
# Uncopyrighted 2011 Enric Morales

# {{ Global variables
origin_dir="/home/kiike/build/i686"
dest_dir="/home/kiike/build/ppc"
repo_path="/home/kiike/build/repo/breakit.db.tar.gz"
chroot_dir="/home/kiike/build"
default_chroot="archppc"
#}}

# {{ Set some bash options
shopt -s extglob		# This allows us to exlude files in the up() function.
# }}

function add() {
  for i in *
    do  if [ ! -d ${origin_dir}/$1 ]
          then	echo "ERROR: package $1 not found. Check for typos."
				return 1
	fi
	cd $dest_dir
	mkdir -p $1/{repos,trunk}
	cp -v $origin_dir/$1/trunk/* $dest_dir/$1/trunk/
	svn add $1 && cd $1 && svn commit -m "add $1"
    done
}

function printusage() {
	echo "Usage:  upkg    up [OPTIONS] <PACKAGES>   upgrades the PACKAGES"
        echo "                add <PACKAGES>            adds the PACKAGES to the repos"   
	echo "                check [PACKAGES]          checks all PACKAGES for upgrades"
	echo "                deps  [PACKAGES]          prints the dependencies of PACKAGES"
	echo ""
	echo "	OPTIONS"
        echo "  -C              passes the -c option to makearchrootpkg, to clean the working copy"
        echo "  -i              passes the -i option to makearchrootpkg, to install the package after building"
	echo "  -d              check dependencies of the given packages for upgrades before building"
        echo "  -f              don't ask questions (can be dangerous if the PKGBUILDs are not reviewed"
        echo "  -l COPY         working copy name (default: $default_chroot)"
	echo "  -[c|t|e]        pushes to [core], [testing] or [extra] respectively"

	exit 1

}

function getdeps() {
  for i in $*
    do	if [ -r $origin_dir/$i/trunk/PKGBUILD ]
		then 	echo "==> Dependencies for $i:" >&2
		else	echo "==> ERROR: package $i not found"
			return 1
	fi
	(source $origin_dir/$i/trunk/PKGBUILD
	for dep in ${depends[@]} ${makedepends[@]}
	   	do echo ${dep%%[<>=]*} | tr '\n' ' '
	done)
	echo
  done
}

function checkdeps() {
  echo -n "==> Checking dependencies... "
    for i in $*
      do if ! vercheck $(getdeps $(getdeps $1))
                  then	echo "ERROR: Outdated dependencies for $1:"
                          vercheck $(getdeps $1)	
                          return 2
                  else	echo "Dependencies for $1 up-to-date."
          fi
      done
}

function vercheck() {
	DEST_PKGBUILD="${origin_dir}/$1/trunk/PKGBUILD"
	ORIGIN_PKGBUILD="${dest_dir}/$1/trunk/PKGBUILD"

	if [ -f ${DEST_PKGBUILD} ]
			then
			source $DEST_PKGBUILD
			DEST_VER=$pkgver-$pkgrel
		else
			return 1
	fi 

	source $ORIGIN_PKGBUILD
	ORIGIN_VER=$pkgver-$pkgrel

	if [ $(vercmp $DEST_VER $ORIGIN_VER) == "1" ]
	#if [[ "$DEST_VER" != "$ORIGIN_VER" ]]
		then
			if [ "$quiet" == "true" ]
				then
					echo -n "$1 "
				else
					echo "$1 ($ORIGIN_VER -> $DEST_VER)"
			fi
			return 2
		else
			return 0
	fi
}

function pushtorepos() {
	[[ $totesting == "true" ]] && testingpkg -m 'Updated'
	[[ $toextra == "true" ]] && extrapkg -m 'Updated'
	if [ -z $toextra ] && [ -z $totesting ]; then
		echo -n "Push to [e]xtra or [t]esting? [e/t] " && read dest_repo
		case $dest_repo in
			t) testingpkg -m "Updated" ;;
			e) extrapkg -m "Updated" ;;
			c) corepkg -m "Updated" ;;
		esac
	fi
}

function up() {
	origin_trunk=${origin_dir}/$1/trunk
	dest_trunk=${dest_dir}/$1/trunk
	
	if [ ! -d ${dest_trunk} ] && [ ! -d ${origin_trunk} ]
		then	echo "==> ERROR: The $1 package build dir wasn't found."
			return 1
	elif [ ! -d ${dest_trunk} ] && [ -d ${origin_trunk} ]
		then	echo "==> Adding package $1..."
			add $1
	fi


	[[ $docheckdeps == "true" ]] && checkdeps $1
	cd ${dest_trunk}
	
	if [ -d src ] || [ -d pkg ]; then
		rm -rf src pkg
	fi
	
	# This function will diff the ORIGIN and DESTINATION directories recursively so that you can
	# review the changes before starting the build process. It's possible to override this by setting
	# the -f flag to the program. It also cleans the folder so that automating svn is easier.
	if [[ $docopy == "true" ]]
                then	rm ${dest_trunk}/!(*.gz|*.part|*.bz2|*.zip|*.xz)
			cp -v $origin_trunk/* ${dest_trunk}

		else	diff --left-column -yr -x '.svn' -x '.git' $PWD ${origin_trunk}/ | less
			echo -n "==> Copy ${origin_trunk} contents to ${dest_trunk}? "
			read copy
			case $copy in
				y|Y)	rm ${dest_trunk}/!(*.gz|*.part|*.bz2|*.zip|*.xz)
					cp -v ${origin_trunk}/* ${dest_trunk}
					;;
				n|N)	echo "   ==> Spawning a shell 'exit' it when done."
					bash
					;;
			esac
	fi

	# These two lines remove files that are not longer in the origin_trunk folder
	# and add the files that don't exist in the DESTINATION_TRUNK folder. 
	(svn status | grep '!') && svn delete $(svn status | grep '!' | tr -d '! ')
	(svn status | grep '?') && svn add $(svn status | grep '?' | tr -d '? ')
	
	mppcadd	
	if sudo makechrootpkg -d -u -r $chroot_dir -l ${working_copy:-$default_chroot}
		then	pushtorepos
		else	exit 1
	fi
} 

case $1 in
	up) 	shift
		while getopts dtefiCcl: arg
			do	case ${arg} in
					d) docheckdeps="true" ;;
					t) totesting="true" ;;
					e) toextra="true" ;;
					f) docopy="true" ;;
					c) tocore="true" ;;
					C) clean_chroot="true" ;;
					i) doinstall="true" ;;
					l) working_copy=$OPTARG ;;
					*) echo "==> ERROR: Invalid argument ${arg}";;
				esac

			done

		shift $(($OPTIND - 1))

		if [[ $toextra == "true" ]] && [[ $totesting == "true" ]] || [[ $tocore == "true" ]]
			then echo "==> ERROR: Please specify a single repository to push to."
		fi


		for i in $*
			do	up $i
				shift
		done
		;;

	deps)	shift
		getdeps $*
		;;

	check)	shift
		if [ -z $1 ]
			then	for i in $(ls $dest_dir)
					do vercheck $i
				done
			else	for i in $*
                                        do vercheck $i
                                done
		fi
		;;
	
	add)	shift
		add $*
		;;

	*)	echo "ERROR: Arguments $* not recognized"
		printusage
		;;
esac

# vim: filetype=sh sts=2 sw=2 ts=8 et
