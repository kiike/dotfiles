#!/usr/bin/env python3

from time import sleep
from subprocess import Popen, PIPE
from sys import exit
import signal

FIFO = '/tmp/panel.fifo'

SEPARATOR = '\\f8 | \\fr'
CENTER = '\c'
RIGHT = '\\r'

LAYOUT = ['W',
          CENTER, 'T',
          RIGHT, 'M', 'K', SEPARATOR, 'B', SEPARATOR, 'D']

def parse_wm_status(line):
    wm_info = line[1:].split(':')
    # Remove monitor label
    wm_info.pop(0)
    # Remove current tiling mode
    wm_info.pop(-1)

    desktops = []
    for d in wm_info:
        # Focused {urgent, occupied} desktops
        if d[0] == 'U' or d[0] == 'O' or d[0] == 'F':
            desktops.append('\\f1{}\\fr'.format(d[1]))

        # Unfocused urgent desktops
        elif d[0] == 'u':
            desktops.append('\\b1\\f8{}\\fr\\br'.format(d[1]))

        # Unfocused unoccupied desktops
        else:
            desktops.append(d[1])

    return ' '.join(desktops)


def parse_win_title(line):
    # Window title starts with T. Put it into the 3rd field
    if len(line) > 69:
        output = '{0}...'.format(line[1:69])
    else:
        output = line[1:]

    return output


def parse_mail_count(line):
    # Capture inbox_check output and return
    if line[1:] != '0':
        output = 'New mail {}'.format(SEPARATOR)
    else:
        output =  ''

    return output


def parse_other(line):
    return line[1:]


def parse(status, line):
    """
    Substitute a part of the "status" list for a parsed version of "line"

    [list], str -> str
    """

    prefix = line[0]

    handler_for = {'W': parse_wm_status,
                   'M': parse_mail_count,
                   'T': parse_win_title,
                   'B': parse_other,
                   'D': parse_other,
                   'K': parse_other}

    status[LAYOUT.index(prefix)] = handler_for[prefix](line)

    return ' '.join(status)


def die():
    """ Kill all the children and exit gracefully """
    print("Killing bar (" + str(bar.pid) + ")")
    bar.kill()
    exit()


def main():
    """ Start the main app loop """
    with open(FIFO) as f:
        current_status = list(LAYOUT)
        while True:
            for line in f:
                stripped_line = line.strip()
                if len(stripped_line) > 0:
                    output = parse(current_status, stripped_line)
                    bar.stdin.write(output + '\n')
                sleep(0.1)


if __name__ == '__main__':
    signal.signal(signal.SIGTERM, die)
    try:
        # Make the bar and get the input from the PIPE
        bar = Popen(['bar', '-p'], stdin=PIPE,
                    universal_newlines=True)

        # Start the program
        main()

    # Capture Ctrl+C
    except KeyboardInterrupt:
        die()
